# note: this reboot strategy is the only way to reliably avoid apt locks during
#       playbook execution
- name: "Disable Unattended Upgrades (if applicable)"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Check for Unattended Upgrades"
        shell:
          cmd: "dpkg -l | grep unattended-upgrades | wc -l"
        register: unattended_upgrades_check
      - name: "Disable Unattended Upgrades"
        when: unattended_upgrades_check.stdout | int > 0
        systemd:
          name: unattended-upgrades
          enabled: no
      - name: "Reboot"
        when: unattended_upgrades_check.stdout | int > 0
        ansible.builtin.reboot:
          post_reboot_delay: 60 # needed to avoid early script termination
          reboot_timeout: 30
          msg: "Reboot initiated by Ansible"
        become: true

- name: "Generate Server Directories"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Create Directories"
        file:
          path: "{{ item }}"
          state: directory
          owner: "{{ ansible_user }}"
          group: "{{ ansible_user }}"
          mode: 0755
        loop:
          - "/var/www"
          - "/var/www/static"
          - "/var/www/static/errors"
          - "/var/www/containers"
          - "/var/www/containers/whoami"
          - "/var/lib/dragon"
      - name: "Copy Error Pages"
        copy:
          src: "files/errors/"
          dest: "/var/www/static/errors/"
          owner: "{{ ansible_user }}"
          group: "{{ ansible_user }}"
          mode: 0644

- name: "Configure UFW Firewall"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Set UFW default incoming policy to deny"
        ufw:
          direction: incoming
          default: deny
      - name: "Set UFW default outgoing policy to allow"
        ufw:
          direction: outgoing
          default: allow
      - name: "Allow SSH access on port 22"
        ufw:
          rule: allow
          to_port: 22
          protocol: tcp
          comment: "Allow SSH connections"
      - name: "Allow HTTP traffic on port 80"
        ufw:
          rule: allow
          to_port: 80
          protocol: tcp
          comment: "Allow HTTP traffic"
      - name: "Allow HTTPS traffic on port 443"
        ufw:
          rule: allow
          to_port: 443
          protocol: tcp
          comment: "Allow HTTPS traffic"
      - name: "Enable UFW logging"
        ufw:
          logging: "on"
      - name: "Enable UFW"
        ufw:
          state: enabled
      - name: Reload UFW firewall
        ufw:
          state: reloaded

- name: "Install System Packages"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Update apt"
        apt:
          update_cache: yes
      - name: "Install packages"
        apt:
          pkg:
          - apt-transport-https
          - ca-certificates
          - curl
          - software-properties-common
          - virtualenv
          - python3-pip
          - python3-setuptools
          - pipx
          state: latest
          update_cache: true

- name: "Install Go"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Get latest Go version"
        shell: curl -s https://go.dev/VERSION?m=text | head -1
        register: go_version
        changed_when: false
      - name: "Download latest Go"
        get_url:
          url: "https://go.dev/dl/{{ go_version.stdout }}.linux-amd64.tar.gz"
          dest: "/tmp/{{ go_version.stdout }}.linux-amd64.tar.gz"
          mode: '0644'
      - name: "Remove existing Go installation"
        file:
          path: /usr/local/go
          state: absent
      - name: "Extract Go"
        unarchive:
          src: "/tmp/{{ go_version.stdout }}.linux-amd64.tar.gz"
          dest: /usr/local
          remote_src: yes
      - name: "Add Go to system PATH"
        copy:
          dest: /etc/profile.d/go.sh
          content: |
            export PATH=$PATH:/usr/local/go/bin
          mode: '0644'
      - name: "Create Go bin symlink"
        file:
          src: /usr/local/go/bin/go
          dest: /usr/bin/go
          state: link
      - name: "Clean up Go tarball"
        file:
          path: "/tmp/{{ go_version.stdout }}.linux-amd64.tar.gz"
          state: absent

- name: "Install Docker"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Add Docker GPG apt Key"
        apt_key:
          url: https://download.docker.com/linux/ubuntu/gpg
          state: present
      - name: "Add Docker Repository"
        apt_repository:
          repo: deb https://download.docker.com/linux/ubuntu focal stable
          state: present
      - name: "Install docker-ce"
        apt:
          name: docker-ce
          state: latest
          update_cache: true
      - name: "Set Docker Context to default"
        shell: docker context use default

- name: "Create Dragon User"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Create 'dragon' user with sudo and docker access"
        user:
          name: dragon
          groups: sudo,docker
          shell: /bin/bash
          create_home: yes
          state: present
      - name: "Create .ssh directory for dragon user"
        file:
          path: /home/dragon/.ssh
          state: directory
          owner: dragon
          group: dragon
          mode: '0700'
      - name: "Configure passwordless sudo for dragon user"
        copy:
          dest: /etc/sudoers.d/dragon
          content: |
            dragon ALL=(ALL) NOPASSWD:ALL
          owner: root
          group: root
          mode: '0440'
          validate: 'visudo -cf %s'
      - name: "Set ownership of /var/lib/dragon to dragon user"
        file:
          path: /var/lib/dragon
          state: directory
          owner: dragon
          group: dragon
          recurse: yes
      - name: "Set ownership of /var/www/containers to dragon user"
        file:
          path: /var/www/containers
          state: directory
          owner: dragon
          group: dragon
          recurse: yes

- name: "Configure SSH Hardening"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Create sshd_config.d directory if it doesn't exist"
        file:
          path: /etc/ssh/sshd_config.d
          state: directory
          owner: root
          group: root
          mode: '0755'
      - name: "Create SSH hardening configuration"
        copy:
          dest: /etc/ssh/sshd_config.d/99-hardening.conf
          content: |
            # SSH Hardening Configuration
            # Note: PermitRootLogin is set to 'yes' during image build
            # and will be changed to 'no' on first boot after SSH keys are copied to dragon user
            PermitRootLogin yes
            MaxAuthTries 3
            LoginGraceTime 20
            X11Forwarding no
            PermitUserEnvironment no
            AllowAgentForwarding no
            AllowTcpForwarding no
            LogLevel VERBOSE
            DebianBanner no
            MaxStartups 10:30:60
            MaxSessions 10
          owner: root
          group: root
          mode: '0644'

- name: "Configure Kernel Security"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Create kernel security sysctl configuration"
        copy:
          dest: /etc/sysctl.d/99-security.conf
          content: |
            # Kernel Security Hardening
            # Enable TCP SYN Cookie Protection
            net.ipv4.tcp_syncookies = 1
            # Enable Reverse Path Filtering (anti-spoofing)
            net.ipv4.conf.all.rp_filter = 1
            net.ipv4.conf.default.rp_filter = 1
            # Disable ICMP Redirects
            net.ipv4.conf.all.accept_redirects = 0
            net.ipv4.conf.default.accept_redirects = 0
            net.ipv6.conf.all.accept_redirects = 0
            net.ipv6.conf.default.accept_redirects = 0
            # Don't send ICMP redirects
            net.ipv4.conf.all.send_redirects = 0
            net.ipv4.conf.default.send_redirects = 0
            # Disable Source Routing
            net.ipv4.conf.all.accept_source_route = 0
            net.ipv4.conf.default.accept_source_route = 0
            net.ipv6.conf.all.accept_source_route = 0
            net.ipv6.conf.default.accept_source_route = 0
            # Ignore broadcast ICMP requests
            net.ipv4.icmp_echo_ignore_broadcasts = 1
            # Disable magic SysRq key
            kernel.sysrq = 0
          owner: root
          group: root
          mode: '0644'
      - name: "Apply sysctl settings"
        command: sysctl --system

- name: "Install CrowdSec"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Add CrowdSec repository"
        shell: curl -s https://install.crowdsec.net | bash
        args:
          creates: /etc/apt/sources.list.d/crowdsec_crowdsec.list

      - name: "Install CrowdSec security engine"
        apt:
          name: crowdsec
          state: present
          update_cache: yes

      - name: "Install CrowdSec firewall bouncer (iptables)"
        apt:
          name: crowdsec-firewall-bouncer-iptables
          state: present

      - name: "Install CrowdSec Linux collection"
        command: cscli collections install crowdsecurity/linux
        register: linux_collection
        changed_when: "'overwrite' not in linux_collection.stderr"

      - name: "Install CrowdSec SSH collection"
        command: cscli collections install crowdsecurity/sshd
        register: sshd_collection
        changed_when: "'overwrite' not in sshd_collection.stderr"

      - name: "Install CrowdSec Caddy collection"
        command: cscli collections install crowdsecurity/caddy
        register: caddy_collection
        changed_when: "'overwrite' not in caddy_collection.stderr"

      - name: "Create Caddy log acquisition config"
        copy:
          dest: /etc/crowdsec/acquis.d/caddy.yaml
          content: |
            filenames:
              - /var/log/caddy/*.log
            labels:
              type: caddy
          owner: root
          group: root
          mode: 0644

      - name: "Configure firewall bouncer for Docker (add DOCKER-USER chain)"
        blockinfile:
          path: /etc/crowdsec/bouncers/crowdsec-firewall-bouncer.yaml
          marker: "# {mark} ANSIBLE MANAGED - iptables chains config"
          insertafter: "^#iptables_chains:"
          block: |
            iptables_chains:
              - INPUT
              - DOCKER-USER

      - name: "Stop CrowdSec services (will start on first boot)"
        systemd:
          name: "{{ item }}"
          state: stopped
          enabled: yes
        loop:
          - crowdsec
          - crowdsec-firewall-bouncer

      - name: "Copy CrowdSec first-boot script"
        copy:
          src: "scripts/crowdsec-first-boot.sh"
          dest: "/usr/local/bin/crowdsec-first-boot.sh"
          owner: root
          group: root
          mode: 0755

      - name: "Copy Dragon user setup script"
        copy:
          src: "scripts/dragon-user-setup.sh"
          dest: "/usr/local/bin/dragon-user-setup.sh"
          owner: root
          group: root
          mode: 0755

- name: "Install Python"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Register Python 3.X version"
        command: python3 --version
        register: pyver
        changed_when: false
        failed_when: pyver.rc != 0
      - name: "Remove Python 3.X EXTERNALLY-MANAGED file"
        file:
          state: absent
          path: "/usr/lib/python{{ pyver.stdout.split()[1] | regex_search('([0-9]+\\.[0-9]+)') }}/EXTERNALLY-MANAGED"
        when: pyver.stdout | regex_search('3\.[0-9]+')
        # @see: https://github.com/geerlingguy/ansible-role-pip/issues/57
      - name: "Install Docker Module for Python"
        pip:
          name: docker

- name: "Install Caddy"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Create 'caddy' group"
        group:
          name: caddy
          system: yes
      - name: "Create 'caddy' user"
        user:
          name: caddy
          groups: caddy
          shell: /bin/false
          system: yes
          createhome: no
      - name: "Add xCaddy GPG apt Key"
        shell: curl -1sLf 'https://dl.cloudsmith.io/public/caddy/xcaddy/gpg.key' | sudo gpg --dearmor -o /usr/share/keyrings/caddy-xcaddy-archive-keyring.gpg
      - name: "Add xCaddy Repository"
        shell: curl -1sLf 'https://dl.cloudsmith.io/public/caddy/xcaddy/debian.deb.txt' | sudo tee /etc/apt/sources.list.d/caddy-xcaddy.list
      - name: "Install xCaddy"
        apt:
          name: xcaddy
          state: latest
          update_cache: true
      - name: "Build Caddy+Plugins"
        shell: |
          xcaddy build \
          --with github.com/caddy-dns/cloudflare \
          --with github.com/caddy-dns/route53 \
          --with github.com/caddy-dns/digitalocean \
          --with github.com/caddyserver/transform-encoder \
          --with github.com/lucaslorentz/caddy-docker-proxy/plugin/v2
      - name: "Install caddy"
        shell: mv caddy /usr/bin/caddy
      - name: "Create Caddy Directories"
        file:
          path: "{{ item }}"
          state: directory
          owner: caddy
          group: caddy
          mode: 0775
        loop:
          - "/var/log/caddy"
          - "/var/www/_caddy"
          - "/var/www/_caddy/storage"
          - "/var/www/_caddy/storage/locks"
      - name: "Set Caddy Folder Permissions"
        shell: chown -R caddy:caddy /var/www/_caddy
      - name: "Generate '/var/www/_caddy/Caddyfile'"
        copy:
          dest: /var/www/_caddy/Caddyfile
          content: |
            {
                # https://caddyserver.com/docs/caddyfile/options

                default_sni example.com
                email example@example.com
                storage file_system /var/www/_caddy/storage

                log default {
                    output file /var/log/caddy/access.log {
                        mode               644
                        roll_size          100MiB
                        roll_keep          10
                        roll_keep_for      2160h # 90 days
                    }

                    format json
                    level ERROR
                }

                # disables getting certificates externally:
                # local_certs

                # DNS/CLOUDFLARE: https://github.com/caddy-dns/cloudflare
                #acme_dns cloudflare {
                #  zone_token env.CLOUDFLARE_ZONE_TOKEN
                #  api_token env.CLOUDFLARE_API_TOKEN
                #}

                # DNS/DIGITALOCEAN: https://github.com/caddy-dns/digitalocean
                # acme_dns digitalocean {env.DIGITALOCEAN_TOKEN}

                # DNS/ROUTE53: https://github.com/caddy-dns/route53
                #acme_dns route53 {
                #  max_retries 10 // optional
                #  profile "real-profile" // defaults to $AWS_PROFILE
                #  access_key_id "AKI..." // required if $AWS_ACCESS_KEY_ID is not defined
                #  secret_access_key "wJa..." // required if $AWS_SECRET_ACCESS_KEY is not defined
                #  session_token "TOKEN..." // defaults to $AWS_SESSION_TOKEN (optional)
                #  region "us-east-1" // required if $AWS_REGION is not defined
                #  max_wait_dur 60, // propagation wait duration in seconds (optional)
                #  wait_for_propagation false // wait for records to propagate (optional)
                #  hosted_zone_id ZABCD1EFGHIL // AWS hosted zone ID to update (optional)
                #}

                # Prefer Let's Encrypt, fall back to ZeroSSL
                cert_issuer acme {
                    dir https://acme-v02.api.letsencrypt.org/directory
                }

                servers :443 {
                  name https
                }

                servers :80 {
                  name http
                }
            }

            # Handle ACME challenges on HTTP, redirect everything else to HTTPS
            http:// {
                @acme path /.well-known/acme-challenge/*
                handle @acme {
                    # Caddy's internal ACME solver handles this automatically
                }
                handle {
                    redir https://{host}{uri} permanent
                }
            }

            # Base domain handler - serves 404 for undefined routes
            # This gets a certificate for the base domain (from default_sni)
            example.com {
                root * /var/www/static/errors
                rewrite * /404.html
                file_server
            }

            # Error page snippet - can be imported by site blocks
            (error_pages) {
                handle_errors {
                    @404 expression {err.status_code} == 404
                    @5xx expression {err.status_code} >= 500 && {err.status_code} < 600

                    root * /var/www/static/errors
                    rewrite @404 /404.html
                    rewrite @5xx /500.html
                    file_server
                }
            }

            static.example.com {
                root * /var/www/static
                file_server
                import error_pages
            }

          owner: caddy
          group: caddy
          mode: 0775
      - name: "Generate '/etc/systemd/system/caddy.service'"
        copy:
          dest: /etc/systemd/system/caddy.service
          content: |
            # run `systemctl daemon-reload` after editing this file

            [Unit]
            Description=Caddy
            Documentation=https://caddyserver.com/docs/
            After=network.target network-online.target
            Requires=network-online.target

            [Service]
            Type=notify
            User=caddy
            Group=caddy
            ExecStart=/usr/bin/caddy docker-proxy --ingress-networks caddy --caddyfile-path /var/www/_caddy/Caddyfile
            ExecReload=/usr/bin/caddy reload --config /var/www/_caddy/Caddyfile --force
            TimeoutStopSec=5s
            LimitNOFILE=1048576
            PrivateTmp=true
            ProtectSystem=full
            AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE

            [Install]
            WantedBy=multi-user.target
          owner: caddy
          group: caddy
          mode: 0755
      - name: "Create Caddy Log Symlink"
        shell: ln -s /var/log/caddy /var/www/_caddy/logs
      - name: "Create Caddy Service Symlink"
        shell: ln -s /etc/systemd/system/caddy.service /var/www/_caddy/caddy.service
      - name: "Reload systemd"
        systemd:
          daemon_reload: yes

- name: "Configure Caddy & Docker"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Add user 'caddy' to 'docker' group"
        user:
          name: caddy
          groups: docker
          append: yes
      - name: "Add user '{{ ansible_user }}' to 'caddy' group"
        user:
          name: "{{ ansible_user }}"
          groups: caddy
          append: yes
      - name: "Add user 'dragon' to 'caddy' group"
        user:
          name: dragon
          groups: caddy
          append: yes
      - name: "Create Docker Network 'caddy'"
        docker_network:
          name: caddy
          state: present
      - name: "Generate '/var/www/containers/whoami/docker-compose.yml'"
        copy:
          dest: /var/www/containers/whoami/docker-compose.yml
          content: |
            services:
              whoami:
                image: traefik/whoami
                networks:
                  - caddy
                labels:
                  caddy: whoami.example.com
                  caddy.reverse_proxy: "{{ '{{upstreams 80}}' }}"

            networks:
              caddy:
                external: true
          group: "{{ ansible_user }}"
          owner: "{{ ansible_user }}"
          mode: 0755

- name: "Update/Upgrade Packages"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Upgrade apt Packages"
        apt:
          upgrade: yes
          update_cache: yes
          cache_valid_time: 86400 #One day
      - name: "Enable Unattended Upgrades (if applicable)"
        when: unattended_upgrades_check.stdout | int > 0
        systemd:
          name: unattended-upgrades
          enabled: yes

- name: "Configure Login Security"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Disable Password Logins"
        shell: "sed -i -E 's/#?PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config && service ssh restart"
      - name: "Allow public key authentication"
        shell: "sed -i -E 's/#?PubkeyAuthentication no/PubkeyAuthentication yes/' /etc/ssh/sshd_config && service ssh restart"

- name: "Configure Welcome Screen"
  hosts: all
  become: true
  tasks:
    - block:
      - name: "Copy dragon-welcome-screen.sh to /etc/profile.d/"
        copy:
          src: "scripts/dragon-welcome-screen.sh"
          dest: "/etc/profile.d/dragon-welcome-screen.sh"
          group: "{{ ansible_user }}"
          owner: "{{ ansible_user }}"
          mode: 0755
